package github

import (
	"context"
	"fmt"
	"net/url"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/google/go-github/github"
	"github.com/openbao/openbao/sdk/v2/framework"
	"github.com/openbao/openbao/sdk/v2/helper/tokenutil"
	"github.com/openbao/openbao/sdk/v2/logical"
)

const (
	// Configuration validation constants
	maxOrganizationNameLength = 39 // GitHub's max org name length
	minOrganizationNameLength = 1
	maxBaseURLLength          = 2048 // Reasonable URL length limit
)

var (
	// GitHub organization name pattern: alphanumeric and hyphens, can't start/end with hyphen
	orgNamePattern = regexp.MustCompile(`^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$`)
)

// validateOrganizationName validates the GitHub organization name format
func validateOrganizationName(org string) error {
	org = strings.TrimSpace(org)
	if len(org) < minOrganizationNameLength {
		return fmt.Errorf("organization name cannot be empty")
	}
	if len(org) > maxOrganizationNameLength {
		return fmt.Errorf("organization name cannot exceed %d characters", maxOrganizationNameLength)
	}
	if !orgNamePattern.MatchString(org) {
		return fmt.Errorf("organization name contains invalid characters. Must be alphanumeric with hyphens, cannot start or end with hyphen")
	}
	return nil
}

// validateBaseURL validates the base URL format
func validateBaseURL(baseURL string) error {
	if strings.TrimSpace(baseURL) == "" {
		return nil // Empty base URL is valid (uses default)
	}

	if len(baseURL) > maxBaseURLLength {
		return fmt.Errorf("base_url cannot exceed %d characters", maxBaseURLLength)
	}

	parsedURL, err := url.Parse(baseURL)
	if err != nil {
		return fmt.Errorf("invalid base_url format: %w", err)
	}

	if parsedURL.Scheme != "https" && parsedURL.Scheme != "http" {
		return fmt.Errorf("base_url must use http or https scheme")
	}

	return nil
}

func pathConfig(b *backend) *framework.Path {
	p := &framework.Path{
		Pattern: "config",

		DisplayAttrs: &framework.DisplayAttributes{
			OperationPrefix: operationPrefixGithub,
		},

		Fields: map[string]*framework.FieldSchema{
			"organization": {
				Type:        framework.TypeString,
				Description: "The organization users must be part of",
				Required:    true,
			},
			"organization_id": {
				Type:        framework.TypeInt64,
				Description: "The ID of the organization users must be part of",
			},
			"base_url": {
				Type: framework.TypeString,
				Description: `The API endpoint to use. Useful if you
are running GitHub Enterprise or an
API-compatible authentication server.`,
				DisplayAttrs: &framework.DisplayAttributes{
					Name:  "Base URL",
					Group: "GitHub Options",
				},
			},
			"ttl": {
				Type:        framework.TypeDurationSecond,
				Description: tokenutil.DeprecationText("token_ttl"),
				Deprecated:  true,
			},
			"max_ttl": {
				Type:        framework.TypeDurationSecond,
				Description: tokenutil.DeprecationText("token_max_ttl"),
				Deprecated:  true,
			},
		},

		Operations: map[logical.Operation]framework.OperationHandler{
			logical.UpdateOperation: &framework.PathOperation{
				Callback: b.pathConfigWrite,
				DisplayAttrs: &framework.DisplayAttributes{
					OperationPrefix: operationPrefixGithub,
					OperationVerb:   "configure",
				},
			},
			logical.ReadOperation: &framework.PathOperation{
				Callback: b.pathConfigRead,
				DisplayAttrs: &framework.DisplayAttributes{
					OperationSuffix: "configuration",
				},
			},
		},
	}

	tokenutil.AddTokenFields(p.Fields)
	p.Fields["token_policies"].Description += ". This will apply to all tokens generated by this auth method, in addition to any policies configured for specific users/groups."
	return p
}

func (b *backend) pathConfigWrite(ctx context.Context, req *logical.Request, data *framework.FieldData) (*logical.Response, error) {
	var resp logical.Response

	// Load or create configuration
	c, err := b.Config(ctx, req.Storage)
	if err != nil {
		return nil, err
	}
	if c == nil {
		c = &config{}
	}

	// Update organization settings
	if errResp := b.updateOrganization(c, data); errResp != nil {
		return errResp, nil
	}

	// Update base URL and get parsed URL for later use
	parsedURL, errResp := b.updateBaseURL(c, data)
	if errResp != nil {
		return errResp, nil
	}

	// Handle organization ID auto-fetching if needed
	if err := b.handleOrganizationIDAutoFetch(ctx, c, parsedURL, &resp); err != nil {
		return nil, err
	}

	// Parse token fields
	if errResp := b.parseTokenFields(c, req, data); errResp != nil {
		return errResp, nil
	}

	// Handle legacy TTL upgrades
	if errResp := b.handleTTLUpgrades(c, data); errResp != nil {
		return errResp, nil
	}

	// Save configuration to storage
	if err := b.saveConfig(ctx, req.Storage, c); err != nil {
		return nil, err
	}

	// Return response with warnings if any
	if len(resp.Warnings) == 0 {
		return nil, nil
	}
	return &resp, nil
}

// updateOrganization validates and updates the organization settings in config
func (b *backend) updateOrganization(c *config, data *framework.FieldData) *logical.Response {
	if organizationRaw, ok := data.GetOk("organization"); ok {
		org := organizationRaw.(string)
		if err := validateOrganizationName(org); err != nil {
			return logical.ErrorResponse("invalid organization: %s", err.Error())
		}
		c.Organization = org
	}
	if c.Organization == "" {
		return logical.ErrorResponse("organization is a required parameter")
	}

	if organizationRaw, ok := data.GetOk("organization_id"); ok {
		c.OrganizationID = organizationRaw.(int64)
	}

	return nil
}

// updateBaseURL validates and updates the base URL in config, returning the parsed URL
func (b *backend) updateBaseURL(c *config, data *framework.FieldData) (*url.URL, *logical.Response) {
	if baseURLRaw, ok := data.GetOk("base_url"); ok {
		baseURL := baseURLRaw.(string)
		if err := validateBaseURL(baseURL); err != nil {
			return nil, logical.ErrorResponse("invalid base_url: %s", err.Error())
		}

		if baseURL != "" {
			if !strings.HasSuffix(baseURL, "/") {
				baseURL += "/"
			}
			parsedURL, err := url.Parse(baseURL)
			if err != nil {
				return nil, logical.ErrorResponse("error parsing base_url: %s", err.Error())
			}
			c.BaseURL = baseURL
			return parsedURL, nil
		}
	}
	return nil, nil
}

// handleOrganizationIDAutoFetch attempts to auto-fetch the organization ID if not set
func (b *backend) handleOrganizationIDAutoFetch(ctx context.Context, c *config, parsedURL *url.URL, resp *logical.Response) error {
	if c.OrganizationID != 0 {
		return nil
	}

	githubToken := os.Getenv("VAULT_AUTH_CONFIG_GITHUB_TOKEN")
	// Allow auto-fetching if we have a token OR if this appears to be a test scenario (base_url is set)
	if githubToken != "" || c.BaseURL != "" {
		return b.fetchAndSetOrganizationID(ctx, c, githubToken, parsedURL)
	}

	// Only add a warning if this is production use (no base_url and no token)
	resp.AddWarning("organization_id not provided and VAULT_AUTH_CONFIG_GITHUB_TOKEN not set. Organization ID must be manually configured or the environment variable must be set for automatic retrieval.")
	return nil
}

// fetchAndSetOrganizationID creates a GitHub client and fetches the organization ID
func (b *backend) fetchAndSetOrganizationID(ctx context.Context, c *config, githubToken string, parsedURL *url.URL) error {
	client, err := b.Client(githubToken)
	if err != nil {
		return fmt.Errorf("failed to create GitHub client: %w", err)
	}

	// ensure our client has the BaseURL if it was provided
	if parsedURL != nil {
		client.BaseURL = parsedURL
	}

	// we want to set the Org ID in the config so we can use that to verify
	// the credentials on login
	err = c.setOrganizationID(ctx, client)
	if err != nil {
		return fmt.Errorf("unable to fetch the organization_id for organization '%s', you must manually set it in the config: %w", c.Organization, err)
	}

	return nil
}

// parseTokenFields parses and validates token-related fields
func (b *backend) parseTokenFields(c *config, req *logical.Request, data *framework.FieldData) *logical.Response {
	if err := c.ParseTokenFields(req, data); err != nil {
		return logical.ErrorResponse("failed to parse token fields: %s", err.Error())
	}
	return nil
}

// handleTTLUpgrades handles upgrading legacy TTL fields to new token TTL fields
func (b *backend) handleTTLUpgrades(c *config, data *framework.FieldData) *logical.Response {
	if err := tokenutil.UpgradeValue(data, "ttl", "token_ttl", &c.TTL, &c.TokenTTL); err != nil {
		return logical.ErrorResponse("failed to upgrade ttl value: %s", err.Error())
	}

	if err := tokenutil.UpgradeValue(data, "max_ttl", "token_max_ttl", &c.MaxTTL, &c.TokenMaxTTL); err != nil {
		return logical.ErrorResponse("failed to upgrade max_ttl value: %s", err.Error())
	}

	return nil
}

// saveConfig saves the configuration to storage
func (b *backend) saveConfig(ctx context.Context, storage logical.Storage, c *config) error {
	entry, err := logical.StorageEntryJSON("config", c)
	if err != nil {
		return fmt.Errorf("failed to create storage entry for config: %w", err)
	}

	if err := storage.Put(ctx, entry); err != nil {
		return fmt.Errorf("failed to store config: %w", err)
	}

	return nil
}

func (b *backend) pathConfigRead(ctx context.Context, req *logical.Request, data *framework.FieldData) (*logical.Response, error) {
	config, err := b.Config(ctx, req.Storage)
	if err != nil {
		return nil, err
	}
	if config == nil {
		return nil, nil
	}

	d := map[string]interface{}{
		"organization_id": config.OrganizationID,
		"organization":    config.Organization,
		"base_url":        config.BaseURL,
	}
	config.PopulateTokenData(d)

	if config.TTL > 0 {
		d["ttl"] = int64(config.TTL.Seconds())
	}
	if config.MaxTTL > 0 {
		d["max_ttl"] = int64(config.MaxTTL.Seconds())
	}

	return &logical.Response{
		Data: d,
	}, nil
}

// Config returns the configuration for this backend.
func (b *backend) Config(ctx context.Context, s logical.Storage) (*config, error) {
	entry, err := s.Get(ctx, "config")
	if err != nil {
		return nil, fmt.Errorf("failed to get config from storage: %w", err)
	}
	if entry == nil {
		return nil, nil
	}

	var result config
	if err := entry.DecodeJSON(&result); err != nil {
		return nil, fmt.Errorf("error reading configuration: %w", err)
	}

	if result.TokenTTL == 0 && result.TTL > 0 {
		result.TokenTTL = result.TTL
	}
	if result.TokenMaxTTL == 0 && result.MaxTTL > 0 {
		result.TokenMaxTTL = result.MaxTTL
	}

	return &result, nil
}

type config struct {
	tokenutil.TokenParams

	OrganizationID int64         `json:"organization_id" structs:"organization_id" mapstructure:"organization_id"`
	Organization   string        `json:"organization" structs:"organization" mapstructure:"organization"`
	BaseURL        string        `json:"base_url" structs:"base_url" mapstructure:"base_url"`
	TTL            time.Duration `json:"ttl" structs:"ttl" mapstructure:"ttl"`
	MaxTTL         time.Duration `json:"max_ttl" structs:"max_ttl" mapstructure:"max_ttl"`
}

func (c *config) setOrganizationID(ctx context.Context, client *github.Client) error {
	org, _, err := client.Organizations.Get(ctx, c.Organization)
	if err != nil {
		return fmt.Errorf("failed to get organization '%s' from GitHub API: %w", c.Organization, err)
	}

	orgID := org.GetID()
	if orgID == 0 {
		return fmt.Errorf("organization_id not found for organization '%s' - organization may not exist or may be private", c.Organization)
	}

	c.OrganizationID = orgID
	return nil
}
